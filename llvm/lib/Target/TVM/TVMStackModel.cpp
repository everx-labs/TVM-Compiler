//===--------- TVMStackModel.cpp - Rewrite Reg-forms with S-forms ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// Introduce explicit stack manipulation. Rewrite all register forms of
/// instructions with their stack counterparts.
///
//===----------------------------------------------------------------------===//

#include <unordered_map>

#include "MCTargetDesc/TVMMCTargetDesc.h"
#include "TVM.h"
#include "TVMStack.h"
#include "TVMStackBlockInfo.h"
#include "TVMSubtarget.h"
#include "TVMUtilities.h"

#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/PostOrderIterator.h"
#include "llvm/CodeGen/LiveIntervals.h"
#include "llvm/CodeGen/MachineBlockFrequencyInfo.h"
#include "llvm/CodeGen/MachineDominators.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineLoopInfo.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/Passes.h"
#include "llvm/IR/DebugInfoMetadata.h"
#include "llvm/Support/raw_ostream.h"

#include "TVMInstMappingInfo.inc"

using namespace llvm;

#define DEBUG_TYPE "tvm-stack-model"

#define DEBUG_RPOT    0
#define DEBUG_BBS     0
#define DEBUG_ROADS   0
#define DEBUG_PATTERN 0

namespace {

/// The pass makes stack explicit by rewriting Reg-form instructions with S-form
/// and inserting stack manipulation instructions. The rewriting is done in the
/// following stages:
/// 1. Define roads. Roads are equivalence classes for initial and final stack
/// configurations.
/// 2. Define stack configurations for start and end of each basic block. For
/// now we do it arbitrary having the information about live-ins and live-outs.
/// TODO: We should consider to be more flexibe with stack patterns to reduce
/// number of stack manipulations required.
/// 3. Process basic blocks one by one, knowing the initial and final stack
/// configurations and rewriting all Reg-form instructions to S-form.
class TVMStackModel final : public MachineFunctionPass {
public:
  StringRef getPassName() const override { return "TVM Stack Model"; }

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.addRequired<LiveIntervals>();
    AU.addPreservedID(LiveVariablesID);
    AU.addRequired<MachineLoopInfo>();
    AU.addPreserved<MachineLoopInfo>();
    MachineFunctionPass::getAnalysisUsage(AU);
  }

  bool runOnMachineFunction(MachineFunction &MF) override;

  MachineInstr *optimizeReversible(MachineInstr &MI, const Stack &TheStack);
  /// Inserts necessary stack manipulation instructions to supply \par MI with
  /// the correct data.
  bool processInstruction(MachineInstr &MI, Stack &TheStack);

  /// Calculate required stack manipulations to ship arguments to \par MI.
  /// TODO: Index is a hacky way to work with reverse form of instructions
  /// (e.g. SUBR, STIR, STUXR), it stores LI SlotIndex of the original
  /// definition while the rest parts of the modelling work generated by the
  /// pass SUBR, STIR and so on.
  StackFixup prepareStackFor(MachineInstr &MI, const Stack &StackBefore,
                             SlotIndex Index,
                             std::string *DebugMessage = nullptr);

  /// Calculate stack after \par MI execution.
  /// This fixup is not supposed to be code generated.
  void modelInstructionExecution(const MachineInstr &MI, Stack &StackBefore);

  static char ID; // Pass identification, replacement for typeid
  TVMStackModel() : MachineFunctionPass(ID) {}

private:
  bool runOnBasicBlocks(MachineFunction &MF, const Stack &StartStack);

  /// Calculate equvalent classes on BB's entry / exit stack configuration
  /// and store them as road numbers in BBInfo.
  void prepareRoads(MachineFunction &MF);

  /// Compute road pattern -- a particular stack configuration used accross
  /// the blocks of the road. The pattern is based on the output stack config
  /// of the block which enters the road first in RPO traversal of the CFG.
  void computeRoadPattern(MachineFunction &MF, unsigned RoadIdx,
                          const Stack &OutStack);

  /// Rewrite an instruction in Reg-form to S-form.
  /// \see TVMInstructionInfo.td to learn more.
  void rewriteToSForm(MachineInstr &MI, std::string &PreTermStackString,
                      Stack &TheStack);

  /// Append \par MMB live-ins to \par vregs
  void gatherBlockLiveIns(MachineBasicBlock &MBB, std::set<unsigned> &vregs);
  /// Append \par MMB live-outs to \par vregs
  void gatherBlockLiveOuts(MachineBasicBlock &MBB, std::set<unsigned> &vregs);

  const DILocalVariable *findDebugValue(const MachineInstr &MI,
                                        unsigned Vreg) const;
  std::string prepareInstructionComment(const MachineInstr &MI) const;

  /// Returns true if From -> To branch is a backedge
  bool isBackEdge(const MachineBasicBlock *From,
                  const MachineBasicBlock *To) const;

  TVMFunctionInfo *MFI;
  MachineRegisterInfo *MRI;
  const TargetInstrInfo *TII;
  MachineLoopInfo *Loops;
  LiveIntervals *LIS;

  /// Store requirements on for BB stack configurations
  DenseMap<MachineBasicBlock *, TVMStackBlockInfo> BBInfo;
  unsigned MaxRoads = 0;
  unsigned MaxRoadWidth = 0;
};

} // end anonymous namespace

char TVMStackModel::ID = 0;
INITIALIZE_PASS(TVMStackModel, DEBUG_TYPE, "Stackify register instructions",
                false, false)

FunctionPass *llvm::createTVMStackModel() { return new TVMStackModel(); }

const DILocalVariable *TVMStackModel::findDebugValue(const MachineInstr &MI,
                                                     unsigned Vreg) const {
  auto it = llvm::find_if(*MI.getParent(), [Vreg](const MachineInstr &DI) {
    return DI.isDebugValue() &&
           (DI.getOperand(0).isReg() && DI.getOperand(0).getReg() == Vreg);
  });
  return (it != MI.getParent()->end()) ? it->getDebugVariable() : nullptr;
}

std::string
TVMStackModel::prepareInstructionComment(const MachineInstr &MI) const {
  if (!MI.getNumExplicitDefs())
    return std::string();

  std::string rv;
  raw_string_ostream OS(rv);

  auto OpPrinter = [&OS, &MI, this](const MachineOperand &Operand) {
    if (Operand.isReg()) {
      if (Operand.isUndef())
        OS << "x";
      else
        OS << printReg(Operand.getReg());
      if (auto DbgVar = findDebugValue(MI, Operand.getReg()))
        OS << "(" << DbgVar->getName() << ")";
    } else {
      OS << Operand;
    }
  };
  auto CommaOpPrinter = [&OS, &OpPrinter](const MachineOperand &Operand) {
    OS << ", ";
    OpPrinter(Operand);
  };

  OS << ">";
  OpPrinter(*MI.defs().begin());
  llvm::for_each(drop_begin(MI.defs(), 1), CommaOpPrinter);

  OS << " = " << TII->getName(MI.getOpcode()) << " ";

  auto Uses = MI.uses();
  if (Uses.begin() != Uses.end()) {
    OpPrinter(*MI.uses().begin());
    llvm::for_each(drop_begin(MI.uses(), 1), CommaOpPrinter);
  }
  OS.flush();
  return OS.str();
}

MachineInstr *TVMStackModel::optimizeReversible(MachineInstr &MI,
                                                const Stack &TheStack) {
  MachineInstrBuilder MIB;
  std::unordered_map<unsigned, unsigned> OpcodeMap = {{TVM::SUB, TVM::SUBR},
                                                      {TVM::STI, TVM::STIR},
                                                      {TVM::STU, TVM::STUR},
                                                      {TVM::STIX, TVM::STIXR},
                                                      {TVM::STUX, TVM::STUXR},
                                                      {TVM::SGT, TVM::SLT},
                                                      {TVM::SGE, TVM::SLE},
                                                      {TVM::SLT, TVM::SGT},
                                                      {TVM::SLE, TVM::SGE}};
  switch (MI.getOpcode()) {
  case TVM::SUB:
  case TVM::STU:
  case TVM::STI: {
    assert(MI.getOperand(0).isReg() && MI.getOperand(1).isReg() &&
           MI.getOperand(2).isReg() && "Operands must be registers");
    size_t OrigScore = TheStack.position(MI.getOperand(1).getReg()) == 1;
    OrigScore += TheStack.position(MI.getOperand(2).getReg()) == 0;
    size_t RScore = TheStack.position(MI.getOperand(1).getReg()) == 0;
    RScore += TheStack.position(MI.getOperand(2).getReg()) == 1;
    if (RScore > OrigScore) {
      MIB = BuildMI(*MI.getParent(), &MI, MI.getDebugLoc(),
                    TII->get(OpcodeMap.at(MI.getOpcode())),
                    MI.getOperand(0).getReg())
                .addReg(MI.getOperand(2).getReg())
                .addReg(MI.getOperand(1).getReg());
      if (MI.getOpcode() == TVM::STI || MI.getOpcode() == TVM::STU) {
        assert(MI.getOperand(3).isCImm() && "Operand must be an immediate");
        MIB.addCImm(MI.getOperand(3).getCImm());
      }
    } else {
      return nullptr;
    }
    break;
  }
  case TVM::STIX:
  case TVM::STUX: {
    assert(MI.getOperand(0).isReg() && MI.getOperand(1).isReg() &&
           MI.getOperand(2).isReg() && MI.getOperand(3).isReg() &&
           "Operands must be registers");
    size_t OrigScore = TheStack.position(MI.getOperand(1).getReg()) == 2;
    OrigScore += TheStack.position(MI.getOperand(2).getReg()) == 1;
    size_t RScore = TheStack.position(MI.getOperand(1).getReg()) == 1;
    RScore += TheStack.position(MI.getOperand(2).getReg()) == 2;
    if (RScore > OrigScore) {
      MIB = BuildMI(*MI.getParent(), &MI, MI.getDebugLoc(),
                    TII->get(OpcodeMap.at(MI.getOpcode())),
                    MI.getOperand(0).getReg())
                .addReg(MI.getOperand(2).getReg())
                .addReg(MI.getOperand(1).getReg())
                .addReg(MI.getOperand(3).getReg());
    } else {
      return nullptr;
    }
    break;
  }
  case TVM::SGT:
  case TVM::SGE:
  case TVM::SLT:
  case TVM::SLE: {
    assert(MI.getOperand(0).isReg() && MI.getOperand(1).isReg() &&
           "Operands must be registers");
    size_t OrigScore = TheStack.position(MI.getOperand(1).getReg()) == 1;
    OrigScore += TheStack.position(MI.getOperand(2).getReg()) == 0;
    size_t RScore = TheStack.position(MI.getOperand(1).getReg()) == 0;
    RScore += TheStack.position(MI.getOperand(2).getReg()) == 1;
    if (RScore > OrigScore) {
      MIB = BuildMI(*MI.getParent(), &MI, MI.getDebugLoc(),
                    TII->get(OpcodeMap.at(MI.getOpcode())),
                    MI.getOperand(0).getReg())
                .addReg(MI.getOperand(2).getReg())
                .addReg(MI.getOperand(1).getReg());
    } else {
      return nullptr;
    }
    break;
  }
  default:
    return nullptr;
  }
  MI.eraseFromParent();
  return MIB.getInstr();
}

bool TVMStackModel::processInstruction(MachineInstr &MI, Stack &TheStack) {
  SlotIndex Index = LIS->getInstructionIndex(MI).getRegSlot();
  MachineInstr *NewMI = optimizeReversible(MI, TheStack);
  MachineInstr &CurrentMI = NewMI ? *NewMI : MI;
  auto *MBB = CurrentMI.getParent();
  StackFixup::InstructionGenerator InsertMIs(TII, MFI, MBB, CurrentMI);
  std::string PreTermStackStr;

  StackFixup Fix =
      prepareStackFor(CurrentMI, TheStack, Index, &PreTermStackStr);
  InsertMIs(Fix);
  Fix.apply(TheStack);

  modelInstructionExecution(CurrentMI, TheStack);
  rewriteToSForm(CurrentMI, PreTermStackStr, TheStack);
  return true;
}

// Traverse all basic blocks in machine function and rewrite all instructions
// from R-form to S-form. All function arguments are already in stack.
bool TVMStackModel::runOnBasicBlocks(MachineFunction &MF,
                                     const Stack &StartStack) {
  bool Changed = false;

  auto &FirstBB = MF.front();
  BBInfo[&FirstBB].setFixedBegin(StartStack);

  using RPOTType = ReversePostOrderTraversal<MachineFunction *>;
  RPOTType RPOT(&MF);
#if DEBUG_RPOT
  llvm::dbgs() << "RPOT:";
  for (RPOTType::rpo_iterator I = RPOT.begin(), E = RPOT.end(); I != E; ++I) {
    auto MBB = *I;
    llvm::dbgs() << " " << MBB->getNumber();
  }
  llvm::dbgs() << "\n";
#endif
  for (RPOTType::rpo_iterator I = RPOT.begin(), E = RPOT.end(); I != E; ++I) {
    auto MBB = *I;
    auto &bbInfo = BBInfo[MBB];
    auto CurrentStack = bbInfo.fixedBegin(); // start bb stack here

    for (auto I = MBB->begin(), E = MBB->end(); I != E; ) {
      MachineInstr &MI = *I++;
      assert(!TVM::isArgument(MI));

      if (MI.isDebugInstr() || MI.isLabel())
        continue;
      Changed |= processInstruction(MI, CurrentStack);
    }
    bbInfo.setCalculatedEnd(CurrentStack);
  }
  return Changed;
}

void TVMStackModel::prepareRoads(MachineFunction &MF) {
  MachineBasicBlock &FirstBB = MF.front();

  BBInfo.clear();
  BBInfo.reserve(MF.size());
  for (auto &MBB : MF) {
    BBInfo[&MBB].setMBB(&MBB);
  }

  /// TODO: It's better to encode keep infor about roads with a more expressive
  /// class than unsigned. The suggestion is to use shared_ptr<Stack> instead of
  /// unsigned.
  unsigned curRoad = 1;
  std::deque<MachineBasicBlock *> queueThisRoad;
  queueThisRoad.push_back(&FirstBB);
  BBInfo[&FirstBB].setRoadEnd(curRoad);
  std::deque<MachineBasicBlock *> queueNextRoads;

  auto processSuccessors = [&](MachineBasicBlock *CurBB) {
    auto endRoad = BBInfo[CurBB].roadEnd();
    assert(endRoad && "null CurBB road in processing successors");
    for (auto Succ : CurBB->successors()) {
      auto &CurInfo = BBInfo[Succ];
      auto beginRoad = CurInfo.roadBegin();
      assert((beginRoad == endRoad || !beginRoad) &&
             "Already defined different road");
      if (!beginRoad) {
        CurInfo.setRoadBegin(endRoad);
        queueThisRoad.push_back(Succ);

        // other side of the block
        if (!CurInfo.roadEnd())
          queueNextRoads.push_back(Succ);
      }
    }
  };
  auto processPredecessors = [&](MachineBasicBlock *CurBB) {
    auto beginRoad = BBInfo[CurBB].roadBegin();
    assert(beginRoad && "null CurBB road in processing predecessors");
    for (auto Pred : CurBB->predecessors()) {
      auto &CurInfo = BBInfo[Pred];
      auto endRoad = CurInfo.roadEnd();
      assert((beginRoad == endRoad || !endRoad) &&
             "Already defined different road");
      if (!endRoad) {
        CurInfo.setRoadEnd(beginRoad);
        queueThisRoad.push_back(Pred);

        // other side of the block
        if (!CurInfo.roadBegin())
          queueNextRoads.push_back(Pred);
      }
    }
  };
  do {
    while (!queueThisRoad.empty()) {
      auto CurBB = queueThisRoad.front();
      queueThisRoad.pop_front();
      auto &CurInfo = BBInfo[CurBB];
      if (CurInfo.roadBegin() == curRoad)
        processPredecessors(CurBB);
      if (CurInfo.roadEnd() == curRoad)
        processSuccessors(CurBB);
    }

    ++curRoad;

    while (!queueNextRoads.empty()) {
      auto CurBB = queueNextRoads.front();
      queueNextRoads.pop_front();
      auto &CurInfo = BBInfo[CurBB];
      if (CurInfo.roadBegin() && CurInfo.roadEnd())
        continue;
      assert(!(!CurInfo.roadBegin() && !CurInfo.roadEnd()) &&
             "Both side roads can't be null for block in queueNextRoads");
      if (!CurInfo.roadBegin())
        CurInfo.setRoadBegin(curRoad);
      if (!CurInfo.roadEnd())
        CurInfo.setRoadEnd(curRoad);
      queueThisRoad.push_back(CurBB);
      break;
    }
  } while (!queueThisRoad.empty());

  MaxRoads = curRoad;
}

void TVMStackModel::gatherBlockLiveIns(MachineBasicBlock &MBB,
                                       std::set<unsigned> &vregs) {
  for (unsigned i = 0, e = MRI->getNumVirtRegs(); i != e; ++i) {
    unsigned Reg = Register::index2VirtReg(i);
    if (LIS->hasInterval(Reg)) {
      if (LIS->isLiveInToMBB(LIS->getInterval(Reg), &MBB)) {
        vregs.insert(Reg);
      }
    }
  }
}

void TVMStackModel::gatherBlockLiveOuts(MachineBasicBlock &MBB,
                                        std::set<unsigned> &vregs) {
  for (unsigned i = 0, e = MRI->getNumVirtRegs(); i != e; ++i) {
    unsigned Reg = Register::index2VirtReg(i);
    if (LIS->hasInterval(Reg)) {
      if (LIS->isLiveOutOfMBB(LIS->getInterval(Reg), &MBB)) {
        vregs.insert(Reg);
      }
    }
  }
}

// TODO: For now it only stackifies function arguments. Extend.
bool TVMStackModel::runOnMachineFunction(MachineFunction &MF) {
  LLVM_DEBUG(
      dbgs()
      << "********** Rewrite Instructions in Reg-form to S-form **********\n"
         "********** Function: "
      << MF.getName() << '\n');

  bool Changed = false;
  MFI = MF.getInfo<TVMFunctionInfo>();
  MRI = &MF.getRegInfo();
  TII = MF.getSubtarget<TVMSubtarget>().getInstrInfo();
  Loops = &getAnalysis<MachineLoopInfo>();
  LIS = &getAnalysis<LiveIntervals>();

#if DEBUG_BBS
  for (auto &MBB : MF) {
    llvm::dbgs() << "~~~~~~~~~~~~~~~ bb." << MBB.getNumber() << ":\n";
    std::set<unsigned> LiveIns, LiveOuts;
    gatherBlockLiveIns(MBB, LiveIns);
    gatherBlockLiveOuts(MBB, LiveOuts);
    llvm::dbgs() << "liveins: ";
    for (auto Reg : LiveIns)
      llvm::dbgs() << " %" << TargetRegisterInfo::virtReg2Index(Reg);
    llvm::dbgs() << "\n";
    llvm::dbgs() << "liveouts:";
    for (auto Reg : LiveOuts)
      llvm::dbgs() << " %" << TargetRegisterInfo::virtReg2Index(Reg);
    llvm::dbgs() << "\n";
    for (auto &I : MBB)
      llvm::dbgs() << "  " << I;
    llvm::dbgs() << "\n";
  }
#endif

  MaxRoads = 0;
  MaxRoadWidth = 0;

  prepareRoads(MF);

  MachineBasicBlock &FirstBB = MF.front();
  if (!FirstBB.empty()) {
    auto &ANI = FirstBB.front();

    // Process ARGUMENT_NUM instruction to adjust arguments number on stack.
    if (TVM::isArgumentNum(ANI)) {
      int args = ANI.getOperand(0).getImm();
      for (int i = 0; i < args; i++)
        MFI->addParam(MVT::i64);
      ANI.eraseFromParent();
      Changed = true;
    }
  }

  size_t NumArgs = MFI->numParams();
  Stack StartStack(MF, NumArgs);

  // Handle ARGUMENTS first to ensure that they get the designated numbers.
  for (MachineBasicBlock::iterator I = FirstBB.begin(), E = FirstBB.end();
       I != E;) {
    MachineInstr &MI = *I++;
    if (!TVM::isArgument(MI))
      break;
    unsigned Reg = MI.getOperand(0).getReg();
    assert(!MFI->isVRegStackified(Reg));
    unsigned ArgNo = NumArgs - MI.getOperand(1).getCImm()->getZExtValue() - 1;
    StartStack.set(ArgNo, StackVreg(Reg, findDebugValue(MI, Reg)));
    MI.eraseFromParent();
    Changed = true;
  }

  MFI->setStackModelBBComment(&MF.front(), StartStack.toString());

  if (runOnBasicBlocks(MF, StartStack))
    Changed = true;

  return Changed;
}

void TVMStackModel::computeRoadPattern(MachineFunction &MF, unsigned RoadIdx,
                                       const Stack &OutStack) {
  std::set<MachineBasicBlock *> BBs, SinkBBs;
  for (auto &MBB : MF) {
    auto &Info = BBInfo[&MBB];
    if (Info.roadBegin() == RoadIdx) {
      SinkBBs.insert(&MBB);
      BBs.insert(&MBB);
    }
    if (Info.roadEnd() == RoadIdx)
      BBs.insert(&MBB);
  }

#if DEBUG_ROADS
  llvm::dbgs() << "Road " << RoadIdx << ":";
  for (auto MBB : BBs) {
    auto &Info = BBInfo[MBB];
    llvm::dbgs() << " ";
    if (Info.roadBegin() == RoadIdx)
      llvm::dbgs() << "-";
    llvm::dbgs() << MBB->getNumber();
    if (Info.roadEnd() == RoadIdx)
      llvm::dbgs() << "-";
  }
  llvm::dbgs() << "\n";
#endif

  Stack RoadPattern(MF, 0);
  if (SinkBBs.size() == 1 && (*SinkBBs.begin())->succ_size() == 0) {
    auto *MBB = *SinkBBs.begin();
    std::set<unsigned> Regs;
    gatherBlockLiveIns(*MBB, Regs);
    gatherBlockLiveOuts(*MBB, Regs);
    for (auto Reg : Regs)
      RoadPattern.addDef(Reg, nullptr);
  } else {
    std::set<unsigned> Regs;
    for (auto MBB : BBs) {
      auto &Info = BBInfo[MBB];
      if (Info.roadBegin() == RoadIdx)
        gatherBlockLiveIns(*MBB, Regs);
      if (Info.roadEnd() == RoadIdx)
        gatherBlockLiveOuts(*MBB, Regs);
    }
    // Push remaining road pattern registers on top of the output stack
    // of the block which enters the road first
    for (auto Reg : OutStack)
      Regs.erase(Reg.VirtReg);
    RoadPattern = OutStack;
    for (auto Reg : Regs)
      RoadPattern.addDef(Reg, nullptr);
  }

  for (auto MBB : BBs) {
    auto &Info = BBInfo[MBB];
    if (Info.roadBegin() == RoadIdx) {
      Info.setFixedBegin(RoadPattern.filteredByLiveIns(*MBB, *LIS));
      MFI->setStackModelBBComment(MBB, Info.fixedBegin().toString());
    }
    if (Info.roadEnd() == RoadIdx)
      Info.setFixedEnd(RoadPattern);
  }
}

/// Model stack for a single instruction.
StackFixup TVMStackModel::prepareStackFor(MachineInstr &MI,
                                          const Stack &StackBefore,
                                          SlotIndex Index,
                                          std::string *DebugMessage) {
  if (MI.isImplicitDef())
    return {};

  if (MI.getOpcode() == TVM::HIDDENSTACK) {
    auto Result = MI.getOperand(0);
    auto Operand = MI.getOperand(1);
    assert(Result.isReg() && Operand.isCImm() && "Unexpected instruction format");
    return StackFixup::DiffForHiddenStack(StackBefore,
                                          Operand.getCImm()->getZExtValue(),
                                          Result.getReg());
  }

  auto *MBB = MI.getParent();

#ifndef NDEBUG
  {
    SmallVector<StackVreg, 32> Vregs(
        llvm::make_filter_range(StackBefore, [](StackVreg vreg) {
          return vreg.VirtReg != TVMFunctionInfo::UnusedReg;
        }));

    llvm::sort(Vregs.begin(), Vregs.end());
    auto it = std::unique(Vregs.begin(), Vregs.end());
    assert(it == Vregs.end() && "Vreg duplicates found in stack");
  }
#endif

  // TODO: We can do it inplace.
  Stack TheStack = StackBefore.filteredByMIdefs(MI);

  size_t NumOperands = MI.getNumOperands();

  // FIXME: wrong assumption. There is no function scope in TVM so RET
  // terminates the current continuation - not necessary a function.
  if (MI.isReturn()) {
    if (NumOperands == 0)
      return StackFixup::DiffForReturn(TheStack);
    else if (NumOperands == 1) {
      auto Op = MI.getOperand(0);
      auto Reg = Op.isUndef() ? TVMFunctionInfo::UnusedReg : (unsigned) Op.getReg();
      return StackFixup::DiffForReturn(TheStack, Reg);
    } else {
      SmallVector<unsigned, 16> RetRegs;
      RetRegs.reserve(NumOperands);
      for (const auto &Op : MI.operands())
        RetRegs.push_back(Op.isUndef() ? TVMFunctionInfo::UnusedReg
                                       : (unsigned) Op.getReg());
      return StackFixup::DiffForReturnMulti(TheStack, RetRegs);
    }
  }

  bool IsLast = MI.isTerminator() || !MI.getNextNode();
  if (IsLast && MBB->succ_size()) {
    if (!BBInfo[MBB].isFixedEnd()) {
      size_t RegsToConsume = 0;
      if (MI.getOpcode() == TVM::JMPX)
        RegsToConsume = 1;
      else if (MI.getOpcode() == TVM::IFJMP ||
               MI.getOpcode() == TVM::IFNOTJMP)
        RegsToConsume = 2;
      else if (MI.getOpcode() == TVM::IFELSE)
        RegsToConsume = 3;
      auto OutStack = TheStack;
      OutStack.consumeArguments(RegsToConsume);
      computeRoadPattern(*MBB->getParent(), BBInfo[MBB].roadEnd(), OutStack);
      assert(BBInfo[MBB].isFixedEnd());
#if DEBUG_PATTERN
      llvm::dbgs() << "BB #" << MBB->getNumber() << " has entered the road\n";
      llvm::dbgs() << "OutStack  " << OutStack << "\n";
      auto AfterTermStack = BBInfo[MBB].fixedEnd();
      llvm::dbgs() << "FixedEnd  " << AfterTermStack << "\n";
      auto NeedStack = AfterTermStack.withArgs(MIArgs(MI, *LIS, Index));
      NeedStack.filterByImpDefs(TheStack);
      llvm::dbgs() << "NeedStack " << NeedStack << "\n";
#endif
    }

    // For terminator instruction we need to prepare stack as
    //  dst road pattern plus required arguments
    auto AfterTermStack = BBInfo[MBB].fixedEnd();
    auto NeedStack = AfterTermStack.withArgs(MIArgs(MI, *LIS, Index));
    NeedStack.filterByImpDefs(TheStack);
    auto Fix = NeedStack - TheStack;
    if (DebugMessage)
      *DebugMessage = NeedStack.toString();
    return Fix;
  } else {
    return StackFixup::DiffForArgs(TheStack, MIArgs(MI, *LIS, Index),
                                   MI.isCommutable());
  }
}

void TVMStackModel::modelInstructionExecution(const MachineInstr &MI,
                                              Stack &StackBefore) {
  if (MI.isImplicitDef())
    return;
  size_t NumDefs = MI.getNumDefs();
  size_t NumStackOperands = llvm::count_if(
      MI.uses(), [](const MachineOperand &MO) { return MO.isReg(); });
  unsigned NumToConsume = NumStackOperands;
#ifndef NDEBUG
  // Let's ensure that consumed registers are used in instruction
  // TODO: Doesn't cover numerous corner cases. Covering them would require to
  // reimplement consumption under NDEBUG or extending consumption interface.
  auto revUses = reverse(MI.uses());
  for (unsigned I = 0; I < NumToConsume; I++) {
    if (MI.isCommutable()) {
      auto regUse = llvm::find_if(revUses, [&](const MachineOperand &Op) {
        return Op.isReg() && StackBefore.reg(I) == Op.getReg();
      });
      assert(regUse != revUses.end() &&
             "Consuming register not used in instruction");
    } else {
      auto regUse = llvm::find_if(
          revUses, [&](const MachineOperand &Op) { return Op.isReg(); });
      assert(regUse != revUses.end() &&
             "Consuming register not used in instruction");

      assert(regUse->isUndef() ||
             regUse->getReg() == StackBefore.reg(I) &&
                 "Wrong register for consuming in instruction");

      revUses = llvm::make_range(++regUse, revUses.end());
    }
  }
#endif
  StackBefore.consumeArguments(NumToConsume);
  for (size_t OpNo = 0; OpNo < NumDefs; ++OpNo) {
    const auto &Operand = MI.getOperand(OpNo);
    assert(Operand.isReg() && "Def must be a register");
    StackBefore.addDef(Operand.getReg(), findDebugValue(MI, Operand.getReg()));
  }
}

void TVMStackModel::rewriteToSForm(MachineInstr &MI,
                                   std::string &PreTermStackString,
                                   Stack &TheStack) {
  size_t NumDefs = MI.getNumDefs();
  size_t NumOperands = MI.getNumOperands();
  int NewOpcode = TVM::RegForm2SForm[MI.getOpcode()];

  size_t NumGlobals = llvm::count_if(MI.uses(), [](const MachineOperand &MO) {
    return MO.isGlobal() || MO.isSymbol();
  });
  size_t NumImms = llvm::count_if(MI.uses(), [](const MachineOperand &MO) {
    return MO.isImm() || MO.isCImm();
  });

  if (NewOpcode >= 0) {
    // Global operands and external symbols are represented using GlobalAddress
    // and ExternalSymbol DAG nodes. Because of convention of instruction
    // operands ordering global addresses and external symbols must be placed
    // first before instruction. To avoid custom logic of stack reordering for
    // global/external operands, we transfrom all GlobalAddress and
    // ExternalSymbol nodes to the chain of PUSH_GLOBAL_ADDRESS(_S) instruction
    // and TargetGlobalAddress / TargetExternalSymbol nodes. So by default only
    // PUSH_GLOBAL_ADDRESS instruction may have global/external operand. This
    // instruction has definition with address which can be normally processed
    // using stack model for all further uses of the address result.
    // There are may be exceptions when the transformation to
    // PUSH_GLOBAL_ADDRESS is not needed (for example, for instructions with
    // immediate string operands like LOGSTR). For such cases operands will be
    // passed up to lowering to MCInst where they can be customly processed.

    // add global addresses before the command
    // TODO: continuation must be modelled in the stack then.
    for (unsigned I = 0; I < NumGlobals; I++) {
      const auto &Op = MI.getOperand(NumDefs + I);
      assert((Op.isGlobal() || Op.isSymbol()) &&
             "Expected GlobalAddress/ExternalSymbol");
      if (NewOpcode == TVM::PUSH_GLOBAL_ADDRESS_S) {
        if (Op.isGlobal()) {
          BuildMI(&MI, TII->get(TVM::PUSHCONT_LABEL))
              .addGlobalAddress(Op.getGlobal(), Op.getOffset());
        } else {
          BuildMI(&MI, TII->get(TVM::PUSHCONT_LABEL))
              .addExternalSymbol(Op.getSymbolName(), Op.getOffset());
        }
      }
    }

    MachineInstrBuilder MIB = BuildMI(&MI, TII->get(NewOpcode));

    if (NewOpcode != TVM::PUSH_GLOBAL_ADDRESS_S) {
      for (unsigned I = 0; I < NumGlobals; I++) {
        const auto &Op = MI.getOperand(NumDefs + I);
        MIB->addOperand(Op);
      }
    }

    // Additional immediate is fake op for TVM::PUSHCONT_MBB operation
    if (MI.getOpcode() == TVM::PUSHCONT_MBB) {
      MIB->addOperand(MI.getOperand(1));
    } else {
      for (unsigned I = 0; I < NumImms; I++) {
        // Imms are expected to be in continuous sequence
        //  in register version of MI
        const auto &Op = MI.getOperand(NumOperands - NumImms + I);
        assert(Op.isImm() || Op.isCImm() && "Expected Imm or CImm");
        if (Op.isImm())
          MIB.addImm(Op.getImm());
        else
          MIB.addCImm(Op.getCImm());
      }
    }

    std::vector<unsigned> SourceRegs;
    for (unsigned I = 0; I < MI.getNumOperands(); I++) {
      const auto &Op = MI.getOperand(I);
      if (Op.isReg()) {
        SourceRegs.push_back(Op.getReg());
      }
    }
    MFI->setStackModelSourceRegs(MIB.getInstr(), SourceRegs);

    TheStack.filterByDeadDefs(MI);

    if (NumDefs)
      MFI->addStackModelComment(MIB.getInstr(), prepareInstructionComment(MI));

    if (MI.isTerminator())
      MFI->addStackModelComment(MIB.getInstr(), PreTermStackString + " => " +
                                                    TheStack.toString());
    else
      MFI->addStackModelComment(MIB.getInstr(), TheStack.toString());
  }

  MI.removeFromParent();
}
