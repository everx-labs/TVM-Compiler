///===--- TVMInstMappingInfoEmitter.cpp - Generate REG to S form mapping --===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// TVMInstMappingInfoEmitter generates for each TVM Instruction a mapping
// between its register form (REG-form) and its stack form (S-form). More
// details about these forms could be found in TVMInstrFormats.td in TVM
// backend.
// This mapping is needed to rewrite REG-form, pseudo instruction generated by
// DAG to DAG ISel, with S-form which is the actual instruction used by the
// virtual machine.
//
//===----------------------------------------------------------------------===//

#include "CodeGenDAGPatterns.h"
#include "llvm/TableGen/Record.h"
#include "llvm/TableGen/TableGenBackend.h"

using namespace llvm;

namespace {

/// Emit mappings needed for TVM backend passes to overwrite instructions.
class TVMInstMappingInfoEmitter {
  CodeGenDAGPatterns CDP;

public:
  TVMInstMappingInfoEmitter(RecordKeeper &R) : CDP(R) {}

  /// Build an array RegForm2SForm which maps Register form instruction to the
  /// corresponding Stack form instruction.
  /// RegForm2SForm[index of Reg-form instruction] == corresponding S-form
  /// instruction.
  void run(raw_ostream &OS);
};

} // End anonymous namespace

void TVMInstMappingInfoEmitter::run(raw_ostream &OS) {
  emitSourceFileHeader("Target Instruction Enum Values and Descriptors", OS);

  OS << "namespace llvm {\n\n";
  OS << "namespace TVM {\n\n";

  CodeGenTarget &Target = CDP.getTargetInfo();

  ArrayRef<const CodeGenInstruction *> NumberedInstructions =
      Target.getInstructionsByEnumValue();

  unsigned Num = 0;
  std::map<std::string, int> OpcodesMap;
  for (const CodeGenInstruction *Inst : NumberedInstructions) {
    const Record *Rec = Inst->TheDef;
    if (Rec->isSubClassOf("NI"))
      if (Rec->getValueAsBit("isStackForm"))
        OpcodesMap[Rec->getName().str()] = Num;
    Num++;
  }

  OS << "int RegForm2SForm[] = {\n";

  Num = 0;
  for (const CodeGenInstruction *Inst : NumberedInstructions) {
    std::string Name = Inst->TheDef->getName().str();
    int Idx = -1;
    auto It = OpcodesMap.find(Name + "_S");
    if (It != OpcodesMap.end())
      Idx = It->second;
    OS << "  " << Idx << ", // " << Num << " " << Name << "\n";
    Num++;
  }

  OS << "};\n\n";

  OS << "} // end namespace TVM\n\n";
  OS << "} // end namespace llvm\n\n";
}

namespace llvm {

void EmitTVMInstMappingInfo(RecordKeeper &RK, raw_ostream &OS) {
  TVMInstMappingInfoEmitter(RK).run(OS);
}

} // namespace llvm
